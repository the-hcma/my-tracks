#!/usr/bin/env python3
"""
Tail device generator for OwnTracks backend server.

Fetches the last hour of data from a source device and creates a "tail" device
that follows with similar movements but shifted 2-5 km in a specified direction.

Supports both HTTP and MQTT transport modes.

Usage:
    ./generate-tail [OPTIONS] [DEVICE]

Examples:
    ./generate-tail                              # Uses defaults (hcma -> hcma-tail, east)
    ./generate-tail mydevice                     # Mirror 'mydevice' to 'mydevice-tail'
    ./generate-tail --direction west             # Shift west instead of east
    ./generate-tail --direction north -o 5       # 5 km north
    ./generate-tail --offset-km 3.5 --dry-run    # Preview with 3.5 km offset
    ./generate-tail --mqtt                        # Send via MQTT instead of HTTP
    ./generate-tail --mqtt --mqtt-port 1883       # MQTT with explicit port
"""

# === Auto-activate virtual environment ===
import os
import sys
from pathlib import Path

def _activate_venv() -> None:
    """Find and activate the project's virtual environment."""
    script_dir = Path(__file__).resolve().parent
    venv_python = script_dir / ".venv" / "bin" / "python"
    if venv_python.exists() and sys.executable != str(venv_python):
        os.execv(str(venv_python), [str(venv_python)] + sys.argv)

_activate_venv()
# === End auto-activate ===

import asyncio
import json
import math
import random
import time
import urllib.error
import urllib.request
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Annotated, Any, Optional

import typer
from amqtt.client import MQTTClient
from amqtt.mqtt.constants import QOS_1

app = typer.Typer(
    help="Generate a tail device that mirrors another device's movements",
    add_completion=False,
)

# Runtime config file path (written by my-tracks-server)
RUNTIME_CONFIG = Path(__file__).resolve().parent / "config" / ".runtime-config.json"


def read_mqtt_port_from_config() -> int | None:
    """Read the actual MQTT port from runtime config written by my-tracks-server."""
    if not RUNTIME_CONFIG.exists():
        return None
    try:
        with RUNTIME_CONFIG.open() as f:
            config = json.load(f)
        # Prefer actual_mqtt_port (set after OS allocation), fall back to mqtt_port
        port = config.get("actual_mqtt_port", config.get("mqtt_port"))
        if port is not None and int(port) >= 0:
            return int(port)
        return None
    except (json.JSONDecodeError, OSError, ValueError):
        return None


class MQTTTransport:
    """MQTT client wrapper for publishing OwnTracks messages."""

    def __init__(self, host: str, port: int) -> None:
        self.host = host
        self.port = port
        self.client = MQTTClient(client_id="generate-tail")
        self._connected = False

    async def connect(self, username: str | None = None, password: str | None = None) -> None:
        """Connect to the MQTT broker."""
        # Build connection URI
        if username and password:
            uri = f"mqtt://{username}:{password}@{self.host}:{self.port}/"
        else:
            uri = f"mqtt://{self.host}:{self.port}/"

        await self.client.connect(uri)
        self._connected = True

    async def publish(self, topic: str, payload: dict[str, Any]) -> bool:
        """Publish an OwnTracks message to a topic."""
        if not self._connected:
            return False
        try:
            data = json.dumps(payload).encode("utf-8")
            await self.client.publish(topic, data, qos=QOS_1)
            return True
        except Exception as e:
            typer.echo(f"âŒ MQTT publish failed: {e}", err=True)
            return False

    async def disconnect(self) -> None:
        """Disconnect from the MQTT broker."""
        if self._connected:
            await self.client.disconnect()
            self._connected = False


def get_available_devices(server_url: str) -> list[str]:
    """Fetch list of available devices from the API."""
    url = f"{server_url}/api/locations/?limit=1000"

    try:
        req = urllib.request.Request(url, headers={"Accept": "application/json"})
        with urllib.request.urlopen(req, timeout=10) as response:
            data = json.loads(response.read().decode("utf-8"))
            locations = data.get("results", [])
            # Extract unique device names
            devices = sorted(set(loc.get("device", "") for loc in locations if loc.get("device")))
            return devices
    except urllib.error.URLError:
        return []


def check_server_connectivity(server_url: str) -> bool:
    """Check if the server is reachable."""
    url = f"{server_url}/api/locations/?limit=1"

    try:
        req = urllib.request.Request(url, headers={"Accept": "application/json"})
        with urllib.request.urlopen(req, timeout=5) as response:
            return response.status == 200
    except urllib.error.URLError:
        return False


def get_locations_from_api(server_url: str, device: str, hours: float = 1.0) -> list[dict[str, Any]]:
    """Fetch recent locations for a device from the API."""
    now = int(time.time())
    start_time = now - int(hours * 3600)

    url = f"{server_url}/api/locations/?device={device}&start_time={start_time}&ordering=timestamp&limit=500"
    typer.echo(f"ðŸ“¡ Fetching locations from: {url}")

    try:
        req = urllib.request.Request(url, headers={"Accept": "application/json"})
        with urllib.request.urlopen(req, timeout=10) as response:
            data = json.loads(response.read().decode("utf-8"))
            locations = data.get("results", [])
            typer.echo(f"ðŸ“ Found {len(locations)} location(s) from device '{device}'")
            return locations
    except urllib.error.URLError as e:
        typer.echo(f"âŒ Failed to fetch locations: {e}", err=True)
        return []


class Direction(str, Enum):
    """Cardinal directions for position offset."""

    north = "north"
    south = "south"
    east = "east"
    west = "west"


def shift_position(
    lat: float, lon: float, km: float, direction: Direction
) -> tuple[float, float]:
    """
    Shift position by a given number of kilometers in the specified direction.

    The distance per degree of longitude varies with latitude:
    1 degree longitude â‰ˆ 111.32 km * cos(latitude)
    1 degree latitude â‰ˆ 111.32 km (constant)

    Returns:
        Tuple of (new_lat, new_lon)
    """
    km_per_degree_lat = 111.32
    lat_rad = math.radians(lat)
    km_per_degree_lon = 111.32 * math.cos(lat_rad)

    if direction == Direction.north:
        return (lat + km / km_per_degree_lat, lon)
    elif direction == Direction.south:
        return (lat - km / km_per_degree_lat, lon)
    elif direction == Direction.east:
        return (lat, lon + km / km_per_degree_lon)
    else:  # west
        return (lat, lon - km / km_per_degree_lon)


def create_tail_location(
    original: dict[str, Any],
    tail_device: str,
    offset_km: float,
    direction: Direction,
    randomize: bool = True,
) -> dict[str, Any]:
    """
    Create a tail location from an original location.

    Args:
        original: Original location data from API
        tail_device: Device ID for the tail device
        offset_km: Base offset in kilometers
        direction: Cardinal direction to shift (north, south, east, west)
        randomize: Add small random variation to offset

    Returns:
        OwnTracks-formatted location payload
    """
    lat = float(original.get("latitude", 0))
    lon = float(original.get("longitude", 0))

    # Add small random variation if enabled (Â±10% of offset)
    actual_offset = offset_km
    if randomize:
        actual_offset = offset_km * random.uniform(0.9, 1.1)

    new_lat, new_lon = shift_position(lat, lon, actual_offset, direction)

    # Use original timestamp or current time
    timestamp = original.get("timestamp_unix") or int(time.time())

    return {
        "_type": "location",
        "lat": round(new_lat, 7),
        "lon": round(new_lon, 7),
        "tst": timestamp,
        "tid": tail_device[-2:] if len(tail_device) >= 2 else tail_device,
        "acc": original.get("accuracy", 10),
        "alt": original.get("altitude", 0),
        "vel": original.get("velocity", 0),
        "batt": original.get("battery_level", 50),
        "conn": original.get("connection_type", "w"),
        "topic": f"owntracks/user/{tail_device}",
    }


def send_location_http(server_url: str, location: dict[str, Any]) -> bool:
    """Send a location to the server via HTTP OwnTracks API."""
    url = f"{server_url}/api/locations/"

    try:
        data = json.dumps(location).encode("utf-8")
        req = urllib.request.Request(
            url, data=data, headers={"Content-Type": "application/json"}
        )

        with urllib.request.urlopen(req, timeout=5) as response:
            return response.status in (200, 201)
    except urllib.error.URLError as e:
        typer.echo(f"âŒ Failed to send location: {e}", err=True)
        return False


def format_time_full(timestamp: int) -> str:
    """Format Unix timestamp showing both UTC and local time."""
    utc_dt = datetime.fromtimestamp(timestamp, timezone.utc)
    local_dt = datetime.fromtimestamp(timestamp)
    local_tz = local_dt.astimezone().tzinfo
    return (
        f"UTC: {utc_dt.strftime('%Y-%m-%d %H:%M:%S')} | "
        f"Local ({local_tz}): {local_dt.strftime('%Y-%m-%d %H:%M:%S')}"
    )


@app.command()
def main(
    device: Annotated[
        Optional[str],
        typer.Argument(help="Source device to mirror (default: hcma)"),
    ] = None,
    source: Annotated[
        str,
        typer.Option("--source", "-s", help="Source device to mirror"),
    ] = "hcma",
    tail: Annotated[
        Optional[str],
        typer.Option("--tail", "-t", help="Tail device ID (default: <source>-tail)"),
    ] = None,
    offset_km: Annotated[
        float,
        typer.Option("--offset-km", "-o", help="Offset in km (2-5 recommended)"),
    ] = 3.5,
    direction: Annotated[
        Direction,
        typer.Option("--direction", "-D", help="Direction to shift: north, south, east, west"),
    ] = Direction.east,
    server: Annotated[
        str,
        typer.Option("--server", help="Server URL"),
    ] = "http://localhost:8080",
    hours: Annotated[
        float,
        typer.Option("--hours", "-H", help="Hours of history to fetch"),
    ] = 1.0,
    delay: Annotated[
        float,
        typer.Option("--delay", "-d", help="Delay between sends in seconds"),
    ] = 0.1,
    dry_run: Annotated[
        bool,
        typer.Option("--dry-run", help="Show what would be sent without actually sending"),
    ] = False,
    mqtt: Annotated[
        bool,
        typer.Option("--mqtt", help="Send via MQTT instead of HTTP"),
    ] = False,
    mqtt_host: Annotated[
        str,
        typer.Option("--mqtt-host", help="MQTT broker host (default: localhost)"),
    ] = "localhost",
    mqtt_port: Annotated[
        Optional[int],
        typer.Option("--mqtt-port", help="MQTT broker port (auto-detected from server config if not set)"),
    ] = None,
    mqtt_user: Annotated[
        Optional[str],
        typer.Option("--mqtt-user", help="MQTT username for authentication"),
    ] = None,
    mqtt_password: Annotated[
        Optional[str],
        typer.Option("--mqtt-password", help="MQTT password for authentication"),
    ] = None,
) -> None:
    """
    Generate a tail device that mirrors another device's movements.

    The tail device follows the same path but shifted 2-5 km in the specified
    direction (default: east), useful for testing multi-device scenarios.

    Use --mqtt to send locations via MQTT instead of HTTP. The MQTT port is
    auto-detected from the running server's config, or can be set explicitly.
    """
    # Handle positional device argument (overrides --source if provided)
    if device:
        source = device

    # Default tail name is source-tail
    if tail is None:
        tail = f"{source}-tail"

    # Resolve MQTT port if in MQTT mode
    transport_label = "HTTP"
    if mqtt:
        transport_label = "MQTT"
        if mqtt_port is None:
            detected_port = read_mqtt_port_from_config()
            if detected_port is not None:
                mqtt_port = detected_port
                typer.echo(f"ðŸ” Auto-detected MQTT port: {mqtt_port}")
            else:
                mqtt_port = 1883
                typer.echo(f"â„¹ï¸  No runtime config found, using default MQTT port: {mqtt_port}")

    typer.echo("ðŸš€ Tail Device Generator")
    typer.echo(f"   Source device: {source}")
    typer.echo(f"   Tail device:   {tail}")
    typer.echo(f"   Offset:        {offset_km} km {direction.value}")
    typer.echo(f"   Transport:     {transport_label}")
    if mqtt:
        typer.echo(f"   MQTT broker:   {mqtt_host}:{mqtt_port}")
    else:
        typer.echo(f"   Server:        {server}")
    typer.echo(f"   History:       {hours} hour(s)")
    typer.echo()

    # Check server connectivity first (needed for fetching source locations)
    if not check_server_connectivity(server):
        typer.echo(f"âŒ Cannot connect to server at {server}", err=True)
        typer.echo("   Make sure the server is running: ./my-tracks-server", err=True)
        raise typer.Exit(code=1)

    # Fetch source locations
    locations = get_locations_from_api(server, source, hours)

    if not locations:
        typer.echo(f"âŒ No locations found for source device '{source}'", err=True)
        typer.echo()

        # Try to help the user by listing available devices
        available = get_available_devices(server)
        if available:
            typer.echo("ðŸ’¡ Available devices:", err=True)
            for dev in available[:10]:  # Show up to 10
                typer.echo(f"   â€¢ {dev}", err=True)
            if len(available) > 10:
                typer.echo(f"   ... and {len(available) - 10} more", err=True)
        else:
            typer.echo("ðŸ’¡ No devices found in database. Is the server running?", err=True)
            typer.echo(f"   Server URL: {server}", err=True)

        raise typer.Exit(code=1)

    typer.echo()
    mode_prefix = "[DRY RUN] Would send" if dry_run else "Sending"
    typer.echo(f"ðŸ“¤ {mode_prefix} {len(locations)} tail locations via {transport_label}...")
    typer.echo()

    if mqtt and not dry_run:
        assert mqtt_port is not None
        asyncio.run(_send_via_mqtt(
            locations, tail, offset_km, direction, source,
            mqtt_host, mqtt_port, mqtt_user, mqtt_password, delay,
        ))
    else:
        _send_via_http(
            locations, tail, offset_km, direction, source,
            server, delay, dry_run,
        )


def _send_via_http(
    locations: list[dict[str, Any]],
    tail: str,
    offset_km: float,
    direction: Direction,
    source: str,
    server_url: str,
    delay: float,
    dry_run: bool,
) -> None:
    """Send tail locations via HTTP."""
    sent = 0
    failed = 0

    for i, loc in enumerate(locations, 1):
        tail_loc = create_tail_location(loc, tail, offset_km, direction)
        _print_location_info(i, len(locations), loc, tail_loc, source, tail)

        if dry_run:
            typer.echo(f"      Payload: {json.dumps(tail_loc)}")
            typer.echo("      Status:  [DRY RUN - not sent]")
        else:
            if send_location_http(server_url, tail_loc):
                sent += 1
                typer.echo("      Status:  âœ“ Sent via HTTP")
            else:
                failed += 1
                typer.echo("      Status:  âœ— Failed to send")

            if delay > 0 and i < len(locations):
                time.sleep(delay)
        typer.echo()

    _print_summary(len(locations), sent, failed, dry_run)


async def _send_via_mqtt(
    locations: list[dict[str, Any]],
    tail: str,
    offset_km: float,
    direction: Direction,
    source: str,
    mqtt_host: str,
    mqtt_port: int,
    mqtt_user: str | None,
    mqtt_password: str | None,
    delay: float,
) -> None:
    """Send tail locations via MQTT."""
    transport = MQTTTransport(mqtt_host, mqtt_port)

    try:
        typer.echo(f"ðŸ”Œ Connecting to MQTT broker at {mqtt_host}:{mqtt_port}...")
        await transport.connect(mqtt_user, mqtt_password)
        typer.echo("âœ… Connected to MQTT broker")
        typer.echo()
    except Exception as e:
        typer.echo(f"âŒ Failed to connect to MQTT broker: {e}", err=True)
        typer.echo("   Make sure the server is running with MQTT enabled: ./my-tracks-server", err=True)
        raise typer.Exit(code=1)

    sent = 0
    failed = 0

    try:
        for i, loc in enumerate(locations, 1):
            tail_loc = create_tail_location(loc, tail, offset_km, direction)
            topic = tail_loc.pop("topic", f"owntracks/user/{tail}")
            _print_location_info(i, len(locations), loc, tail_loc, source, tail)
            typer.echo(f"      Topic:    {topic}")

            if await transport.publish(topic, tail_loc):
                sent += 1
                typer.echo("      Status:  âœ“ Published via MQTT")
            else:
                failed += 1
                typer.echo("      Status:  âœ— Failed to publish")

            if delay > 0 and i < len(locations):
                await asyncio.sleep(delay)
            typer.echo()
    finally:
        await transport.disconnect()
        typer.echo("ðŸ”Œ Disconnected from MQTT broker")

    _print_summary(len(locations), sent, failed, dry_run=False)


def _print_location_info(
    index: int,
    total: int,
    original: dict[str, Any],
    tail_loc: dict[str, Any],
    source: str,
    tail: str,
) -> None:
    """Print location details for a single point."""
    orig_lat = float(original.get("latitude", 0))
    orig_lon = float(original.get("longitude", 0))

    typer.echo(f"  [{index}/{total}] tst={tail_loc['tst']}")
    typer.echo(f"      Timestamp:    {format_time_full(tail_loc['tst'])}")
    typer.echo(f"      Original ({source}): ({orig_lat:.6f}, {orig_lon:.6f})")
    typer.echo(f"      Shifted ({tail}):  ({tail_loc['lat']:.6f}, {tail_loc['lon']:.6f})")


def _print_summary(total: int, sent: int, failed: int, dry_run: bool) -> None:
    """Print final summary."""
    typer.echo()
    if dry_run:
        typer.echo(f"âœ… Dry run complete. Would have sent {total} locations.")
    else:
        typer.echo(f"âœ… Complete. Sent: {sent}, Failed: {failed}")

    if failed > 0:
        raise typer.Exit(code=1)


if __name__ == "__main__":
    app()